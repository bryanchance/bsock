/* bindsocket - bind() sockets to restricted ports for lower-privilege daemons
 *
 * Historically, ports 1-1023 are restricted and only root can bind to them.
 *   (IPPORT_RESERVED = 1024)
 * Traditionally, there have been two ways to run non-root daemons on low ports:
 * a) inetd  (root daemon listens on low port and for each connection accept()s,
 *    fork()s, drop privileges, exec()s non-root daemon for single connection)
 * b) daemon starts up as root, bind()s to low port, and drops root privileges
 *
 * For performance, many daemons use the method in b), but that means that
 * potentially complex programs are starting up as root, following instructions
 * in configuration files, and potentially creating exposures.
 *
 * bindsocket aims to provide a third method to bind to low ports, with all
 * the benefits of b), but without having to start up the daemon as root.
 *
 * bindsocket is a simple root daemon that listens for requests on a local unix
 * domain socket.  Connections to the socket are authenticated using credentials
 * supplied by the operating system (and can be trusted).  The configuration
 * file for bindsocket specifies which users can request sockets on which 
 * addresses and ports.  bindsocket authorizes the socket request, binds to
 * the address and port, and then passes the bound socket back to the client
 * over the unix domain socket.  The client can set socket options such as
 * SO_KEEPALIVE, SO_SNDBUF, SO_RCVBUF, etc, as well as file descriptor flags
 * (e.g. FD_CLOEXEC), and then listen() / accept() on the socket as if the
 * client process had called bind() itself.  If the client (optionally) passes
 * an unbound socket to the bindsocket daemon along with the addrinfo request,
 * then bindsocket will authorize and bind the address to the socket provided.
 *
 * Another option for using bindsocket is to install it as setuid root program.
 * This is not required if running bindsocket as daemon.  However, if installed
 * setuid root, then a lower-privilege daemon can create a socketpair() of unix
 * domain sockets and can start up bindsocket with one of the sockets on the
 * STDIN_FILENO of bindsocket.  bindsocket will then operate as described above,
 * but only for a single address and port socket request.
 *
 * As a special-case, if zero (0) is the requested port for AF_INET or AF_INET6,
 * then bindsocket will bind to a reserved port < IPPORT_RESERVED (1024).  This
 * could e.g. be used by rsh and ssh if these client programs were setuid 'rsh'
 * or setuid 'ssh', where 'rsh' and 'ssh' were not 'root', and the bindsocket
 * config file permitted these users to request addrinfo specifying port 0.
 * (Better recommendation is to delete rsh and rlogin, and to remove the setid
 * bit from ssh as the setuid root of client ssh program is not required for
 * typical use.)  Note that specifying port 0 traditionally means that the
 * operating system should bind to an ephemeral port, an unprivileged high port,
 * but is used here to indicate a request to bind to a privileged low port.
 * After all, one need not call bindsocket to bind to a privileged port if
 * explicitly calling bind and requesting that the operating system choose an
 * unprivileged port.  Most outbound connections simply call connect() and do
 * not call bind().
 *
 *
 * bindsocket config file line format:
 *     username address_family socket_type protocol service_or_port address
 * - specify separate lines for each difference, since exact match is performed
 * - strings are case-sensitive
 *     use uppercase addr family, socktype constants (e.g. AF_INET, SOCK_STREAM)
 *     use lowercase for protocol (e.g. tcp) or alias in /etc/protocols
 * - use port 0 if service_or_port does not apply to addr family (e.g. AF_UNIX)
 * - blank lines and comments (lines beginning with #) are skipped
 * - address must be an address string not a constant, e.g.
 *    0.0.0.0            (for INADDR_ANY)
 *    127.0.0.1          (for INADDR_LOOPBACK)
 *    255.255.255.255    (for INADDR_BROADCAST)
 *    ::                 (for IN6ADDR_ANY_INIT)
 *    ::1                (for IN6ADDR_LOOPBACK_INIT)
 * (FUTURE: could add parsing for INADDR_ANY and other constants)
 *
 *
 * bindsocket setup
 *   make
 *   make install   # 'install-suid' to install bindsocket setuid root)
 *   # populate config file, e.g. /usr/local/etc/bindsocket
 *     apache AF_INET SOCK_STREAM tcp 80 0.0.0.0
 *
 * Files  (default PREFIX=/usr/local)
 *   /usr/local/etc/bindsocket           # bindsocket authorization (config)
 *   /usr/local/lib/libbindsocket.so     # bindsocket library for client/daemon
 *   /usr/local/sbin/bindsocket          # bindsocket executable (daemon)
 *   /usr/local/var/run/bin/bindsocket/  # dir containing unix domain socket
 *
 * bindsocket logs to LOG_DAEMON syslog facility, by default.
 * Be sure to config /etc/syslog.conf (or /etc/rsyslog.conf) for daemon.info
 * Compile with -DBINDSOCKET_SYSLOG_FACILITY=<digit> to modify.
 * See /usr/include/sys/syslog.h (or similar) for LOG_xxxxx values.
 *
 * bindsocket is installed with ownership root:daemon, permissions 0550 with
 * the 'make install'.  Permissions 4550 are used with 'make install-suid'.
 * Compile with -DBINDSOCKET_GROUP=xxxxx to modify the group ownership.
 * By default, this restricts only those users part of group 'daemon' to run
 * bindsocket.  You are encouraged to use a custom group, e.g. bindsock, and
 * to add to this custom group those specialized role accounts (e.g. apache)
 * under which your daemons run.  This group is also used to permission the
 * bindsocket unix domain socket (e.g. /usr/local/var/run/bindsocket/socket)
 * to restrict which accounts can connect to bindsocket daemon through socket.
 *
 *
 * bindsocket is by no means the end-all-be-all of security.  Defense-in-depth
 * is encouraged.  On Linux, iptables can additionally be used to augment
 * security, as can firewalls external to the host.  SELinux policies or
 * grsecurity might also be used, but bindsocket subverts some of the targetted
 * policies that restrict the ports to which a specific executable can bind.
 *
 *
 * References:
 *   Secure interprocess communication
 *     http://cr.yp.to/docs/secureipc.html
 *   Unix socket magic
 *     http://www.lst.de/~okir/blackhats/node121.html
 *   Linux Socket Programming by Example - Warren Gay
 *     "17. Passing Credentials and File Descriptors"
 *   authbind  (Ian Jackson, 1998)
 *     http://www.chiark.greenend.org.uk/ucgi/~ijackson/cvsweb/authbind
 *
 *
 * Alternative ideas:
 * Another approach (code not written here) might be to have a small setuid root
 * program that bind()s to socket, dup2() to STDIN_FILENO, and then fork()s and
 * exec()s a daemon, which inherits the socket and can listen().  This method
 * would provides only for a single listen() socket, which can meet the needs
 * of some daemons.  Additional descriptors could be opened fds > STDERR_FILENO
 * and would be inherited by the child daemon and child daemon could determine
 * which addresses to which each fd was bound by calling getsockname().  In any
 * case, the root program would need to maintain configuration information about
 * which addresses and ports to bind to and how to exec each program.  It would
 * have an advantage over bindsocket in that a particular program could be
 * associated with a particular address and port.  bindsocket is limited to uid
 * privileging (although it could be extended to get process info on the pid
 * connecting to the unix domain socket).  However, bindsocket is simpler in
 * that it allows the client to request specific addresses as the client desires
 * the socket, rather than possibly opening too many.  Also, bindsocket does not
 * get in the way of programs which supervise daemons, as the program described
 * here might.
 *
 * authbind allows a program which does not or should not run as root to bind
 * a socket to low-numbered ports in a controlled way.  It uses LD_LIBRARY_PATH
 * and interposes a custom bind() to catch and redirect bind() to a privileged
 * subprocess.  [Ed: bindsocket daemon using unix domain sockets to transfer
 * file descriptor was developed prior to the author becoming aware of authbind,
 * and bindsocket use of unix domain sockets provides better error detection.]
 * bindsocket supports IPv4, IPv6, and unix domain sockets.
 * authbind supports only IPv4, though there is a patch for IPv6 support
 *   (http://toroid.org/ams/etc/authbind-ipv6-support)
 * authbind configuration supports multiple ways to authorize bind request
 * including specific IP and port, CIDR prefix matching, and port ranges.
 * bindsocket is intentionally less flexible, supporting only exact matches
 * for IP and port.  authbind distributes the configs in filesystem paths to
 * avoid reading and parsing the entire config for each request, whereas
 * bindsocket currently has a monolithic config file.  If bindsocket config
 * parsing becomes a performance bottleneck, this will be revisited.
 * (Forking for each connection to bindsocket is likely to be bottleneck first.)
 * authbind disallows port >= IPPORT_RESERVED/2 and < IPPORT_RESERVED since
 * those are used by bindresvport() for, e.g. rsh outbound connections.
 * authbind presumably must reject these ports because one authbind config file
 * authorization mode just looks at IP address and will bind to any port
 * requested if the IP address matches.  On the other hand, bindsocket requires
 * explicit specification of port, so if admin explicitly configures a port
 * in the range [IPPORT_RESERVED/2, IPPORT_RESERVED), then bindsocket allows it.
 *
 * Similar to authbind, bindsocket provides a simple .so to interpose the bind()
 * used by unmodified executables so that the bindsocket daemon is called when
 * the executable calls bind().
 *   LD_PRELOAD=/usr/local/lib/libbindsocket_preload.so
 * Implementation consideration when using LD_PRELOAD:
 * If the executable calls bind() with an AF_INET or AF_INET6 addr with port 0,
 * and expects a high port, then bindsocket_preload.c might be modified to
 * detect port 0 and call bind() from libc instead of the bindsocket daemon,
 * which will bind() to a low (privileged) port, if the caller is authorized.
 * Outbound connections from many executables omit the call to bind(), so this
 * is unlikely to be problem for most usage.
 *
 *
 * FUTURE:
 * - create small program that checks for canonicalized strings in config file
 *     and provides more detailed error messages for config file errors
 *     (might do at daemon startup or add command line config check flag)
 *     might create mcdb with hash of canonicalized username + addrinfo strings
 * - provide example client code that interfaces with bindsocket for popular
 *   programs such as Apache.  (Also: graceful Apache restart via transferring
 *   the listening socket(s)).
 * - create test target that compiles with overrides and config file
 *   so that test can occur without root privilege
 *   (create directory with config file 700 for test)
 *   (build with outputs going elsewhere using VPATH and add -I.. so that
 *    developer can not accidentally 'install' test executables)
 * - performance: test what system calls get hit in child in daemon mode.  Then,
 *   add calls to resolve the symbols in daemon parent init so that they are all
 *   loaded before fork().  Link -z now (avoid lazy loading/symbol resolution).
 *   Open config file and stat it after each accept (re-opening if needed).
 *   Benchmark typical service times to one-shot with and without -z now and to
 *   daemon, with and without -z now.  Catch HUP signal and reopen databases
 *   e.g. /etc/services and /etc/protocols (endservent(), endprotoent(), and
 *   then setservent(1) and setprotoent(1) to pass stayopen flag)
 * - run programs with memory leak generators and stuff
 * - port and test bindsocket on additional platforms (FreeBSD, OpenBSD, ...)
 * - sysctl can prevent accidental usage of specific non-privileged ports
 *   http://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt
 *     /proc/sys/net/ipv4/ip_local_port_range
 *     /proc/sys/net/ipv4/ip_local_reserved_ports
 *   Patch Linux kernel to adjust root-reserved ports (1-1023) to larger number
 *   and use bindsocket to dole out standard ports for non-privileged daemons
 *   like Postgres (5432), MySQL (3306), and others, while other non-privileged
 *   accounts (not postgres, mysql, etc) will not be able to bind to those ports
 *   Alternatively, provide features similar to portreserve, but keep a copy of
 *   the socket in the daemon and dole it out to those authorized to receive it.
 *   Doing so removes the race condition where a daemon that is listening on a
 *   non-privileged port restarts and allowing a race condition where another
 *   process owned by a different user grabs the non-privileged port.
 *     (man portreserve)
 */
